{
  "language": "Solidity",
  "sources": {
    "contracts/MultiCall.sol": {
      "content": "pragma solidity 0.8.7;\npragma experimental ABIEncoderV2;\n\nabstract contract Ownable {\n  address private _owner;\n\n  constructor() {\n    _owner = msg.sender;\n  }\n\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    _owner = newOwner;\n  }\n}\n\nabstract contract Constant is Ownable {\n  string public UNKNOWN_STRING = \"UNKNOWN\";\n  uint256 public UNKNOWN_UINT = 9999;\n  address public UNKNOWN_ADDRESS = address(0);\n\n  function setUnKnownString(string memory _unknown) external onlyOwner {\n    UNKNOWN_STRING = _unknown;\n  }\n\n  function setUnknownUint(uint256 _unknown) external onlyOwner {\n    UNKNOWN_UINT = _unknown;\n  }\n\n  function setUnknownAddress(address _unknown) external onlyOwner {\n    UNKNOWN_ADDRESS = _unknown;\n  }\n}\n\nabstract contract Block {\n  function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n    blockHash = blockhash(blockNumber);\n  }\n\n  function getBlockNumber() public view returns (uint256 blockNumber) {\n    blockNumber = block.number;\n  }\n\n  function getCurrentBlockCoinbase() public view returns (address coinbase) {\n    coinbase = block.coinbase;\n  }\n\n  function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n    difficulty = block.difficulty;\n  }\n\n  function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n    gaslimit = block.gaslimit;\n  }\n\n  function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n    timestamp = block.timestamp;\n  }\n\n  function getLastBlockHash() public view returns (bytes32 blockHash) {\n    blockHash = blockhash(block.number - 1);\n  }\n\n  function getBlockBaseFee() public view returns (uint256 baseFee) {\n    require(getChainId() == 1, \"Unable to get baseFee\");\n    baseFee = block.basefee;\n  }\n\n  function getChainId() public view returns (uint256 chainId) {\n    chainId = block.chainid;\n  }\n}\n\nabstract contract Pair is Constant {\n  struct EachPair {\n    address token;\n    uint256 reserve;\n  }\n\n  struct PairInfo {\n    address pair;\n    EachPair token0;\n    EachPair token1;\n  }\n\n  function safePairReserve(address pair) internal view returns (EachPair memory token0, EachPair memory token1) {\n    (bool successToken0, bytes memory token0Bytes) = pair.staticcall(abi.encodeWithSelector(0x0dfe1681));\n    require(successToken0, \"getPairReserve: Invalid Token0\");\n    address token0Address = abi.decode(token0Bytes, (address));\n\n    (bool successToken1, bytes memory token1Bytes) = pair.staticcall(abi.encodeWithSelector(0xd21220a7));\n    require(successToken1, \"getPairReserve: Invalid Token1\");\n    address token1Address = abi.decode(token1Bytes, (address));\n\n    (bool successReserves, bytes memory reserve) = pair.staticcall(abi.encodeWithSelector(0x0902f1ac));\n    require(successReserves, \"getPairReserve: Invalid reserves\");\n    (uint256 token0Reserve, uint256 token1Reserve) = abi.decode(reserve, (uint256, uint256));\n\n    return (EachPair({token: token0Address, reserve: token0Reserve}), EachPair({token: token1Address, reserve: token1Reserve}));\n  }\n\n  function getBatchPairInfos(address[] memory _pairs) public view returns (PairInfo[] memory _pairInfos) {\n    _pairInfos = new PairInfo[](_pairs.length);\n    for (uint256 i = 0; i < _pairs.length; i++) {\n      address targetPair = _pairs[i];\n\n      _pairInfos[i].pair = targetPair;\n      (_pairInfos[i].token0, _pairInfos[i].token1) = safePairReserve(targetPair);\n    }\n  }\n}\n\nabstract contract ERC20 is Constant {\n  struct ERC20Info {\n    string name;\n    string symbol;\n    uint256 decimals;\n    uint256 totalSupply;\n  }\n\n  struct BalanceInfo {\n    address token;\n    uint256 balance;\n  }\n\n  function safeERC20Name(address token) public view returns (string memory) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x06fdde03));\n    return success ? abi.decode(data, (string)) : UNKNOWN_STRING;\n  }\n\n  function safeERC20Symbol(address token) public view returns (string memory) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x95d89b41));\n    return success ? abi.decode(data, (string)) : UNKNOWN_STRING;\n  }\n\n  function safeERC20Decimals(address token) public view returns (uint256) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x313ce567));\n    return success ? abi.decode(data, (uint256)) : UNKNOWN_UINT;\n  }\n\n  function safeERC20TotalSupply(address token) public view returns (uint256) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\n    return success ? abi.decode(data, (uint256)) : UNKNOWN_UINT;\n  }\n\n  function safeERC20BalanceOf(address token, address holder) public view returns (uint256) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x70a08231, holder));\n    return success ? abi.decode(data, (uint256)) : UNKNOWN_UINT;\n  }\n\n  function getBatchERC20TotalSupply(address[] memory _tokens) public view returns (uint256[] memory totalSupplies) {\n    totalSupplies = new uint256[](_tokens.length);\n\n    for (uint256 i = 0; i < _tokens.length; i++) {\n      totalSupplies[i] = safeERC20TotalSupply(_tokens[i]);\n    }\n  }\n\n  function getBatchERC20Infos(address[] memory _tokens) public view returns (ERC20Info[] memory tokenInfos) {\n    tokenInfos = new ERC20Info[](_tokens.length);\n\n    for (uint256 i = 0; i < _tokens.length; i++) {\n      address targetERC20 = _tokens[i];\n      tokenInfos[i] = ERC20Info({\n        name: safeERC20Name(targetERC20), // optional\n        symbol: safeERC20Symbol(targetERC20), // optional\n        decimals: safeERC20Decimals(targetERC20), // required, but for weired token.\n        totalSupply: safeERC20TotalSupply(targetERC20) // required, but for weired token.\n      });\n    }\n  }\n\n  function getBatchERC20Balances(address[] memory users, address[] memory tokens) external view returns (uint256[] memory addrBalances) {\n    addrBalances = new uint256[](tokens.length * users.length);\n\n    for (uint256 i = 0; i < users.length; i++) {\n      for (uint256 j = 0; j < tokens.length; j++) {\n        uint256 addrIdx = j + tokens.length * i;\n        if (tokens[j] != address(0x0)) {\n          addrBalances[addrIdx] = safeERC20BalanceOf(tokens[j], users[i]);\n        } else {\n          addrBalances[addrIdx] = users[i].balance;\n        }\n      }\n    }\n  }\n}\n\nabstract contract ERC721 is Constant {\n  struct ERC721Info {\n    uint256 id;\n    address owner;\n    string tokenURI;\n  }\n\n  function safeERC721OwnerOf(address token, uint256 id) public view returns (address) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\n    return success ? abi.decode(data, (address)) : UNKNOWN_ADDRESS;\n  }\n\n  function safeERC721TokenURI(address token, uint256 id) public view returns (string memory) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0xc87b56dd, id));\n    return success ? abi.decode(data, (string)) : UNKNOWN_STRING;\n  }\n\n  function getBatchERC721Infos(address _token, uint256[] memory _ids) public view returns (ERC721Info[] memory erc721Infos) {\n    erc721Infos = new ERC721Info[](_ids.length);\n\n    for (uint256 i = 0; i < _ids.length; i++) {\n      erc721Infos[i] = ERC721Info({id: _ids[i], owner: safeERC721OwnerOf(_token, _ids[i]), tokenURI: safeERC721TokenURI(_token, _ids[i])});\n    }\n  }\n}\n\nabstract contract ChainLink is Constant {\n  struct ChainLinkData {\n    string description;\n    uint256 answer;\n    uint256 decimals;\n  }\n\n  function safeChainLinkData(address feed) public view returns (ChainLinkData memory) {\n    (bool successDescriptionData, bytes memory desciprtionData) = feed.staticcall(abi.encodeWithSelector(0x7284e416));\n    (bool successRoundData, bytes memory roundData) = feed.staticcall(abi.encodeWithSelector(0xfeaf968c));\n    (bool successDecimalsData, bytes memory decimalsData) = feed.staticcall(abi.encodeWithSelector(0x313ce567));\n\n    string memory description = successDescriptionData ? string(desciprtionData) : UNKNOWN_STRING;\n    (, uint256 answer, , , ) = successRoundData\n      ? abi.decode(roundData, (uint80, uint256, uint256, uint256, uint80))\n      : (0, UNKNOWN_UINT, 0, 0, 0);\n    uint256 decimals = successDecimalsData ? abi.decode(decimalsData, (uint256)) : 0;\n\n    return ChainLinkData({description: description, answer: answer, decimals: decimals});\n  }\n\n  function getBatchChainLinkData(address[] memory _targetFeeds) public view returns (ChainLinkData[] memory _chainLinkData) {\n    _chainLinkData = new ChainLinkData[](_targetFeeds.length);\n    for (uint256 i = 0; i < _targetFeeds.length; i++) {\n      address targetFeed = _targetFeeds[i];\n      _chainLinkData[i] = safeChainLinkData(targetFeed);\n    }\n  }\n}\n\nabstract contract Address {\n  function getCode(address target) public view returns (bytes memory code) {\n    assembly {\n      let size := extcodesize(target)\n      code := mload(0x40)\n      mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n      mstore(code, size)\n      extcodecopy(target, add(code, 0x20), 0, size)\n    }\n  }\n\n  function checkCA(address target) public view returns (bool) {\n    uint256 code;\n    assembly {\n      code := extcodesize(target)\n    }\n    return code > 0;\n  }\n\n  function getBatchGetCode(address[] memory _targetAddress) public view returns (bytes[] memory code) {\n    code = new bytes[](_targetAddress.length);\n    for (uint256 i = 0; i < _targetAddress.length; i++) {\n      code[i] = getCode(_targetAddress[i]);\n    }\n  }\n\n  function getBatchCheckCA(address[] memory _targetAddress) public view returns (bool[] memory result) {\n    result = new bool[](_targetAddress.length);\n    for (uint256 i = 0; i < _targetAddress.length; i++) {\n      result[i] = checkCA(_targetAddress[i]);\n    }\n  }\n}\n\nabstract contract Aggregator {\n  struct Call {\n    address target;\n    bytes callData;\n  }\n\n  struct Result {\n    bool success;\n    bytes returnData;\n  }\n\n  function aggregate(bool requireSuccess, Call[] memory calls) public returns (Result[] memory returnData) {\n    returnData = new Result[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n      (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\n\n      if (requireSuccess) {\n        require(success, \"multicall aggregate: call failed\");\n      }\n\n      returnData[i] = Result(success, ret);\n    }\n  }\n\n  function staticAggregate(bool requireSuccess, Call[] memory calls) public view returns (Result[] memory returnData) {\n    returnData = new Result[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n      (bool success, bytes memory ret) = calls[i].target.staticcall(calls[i].callData);\n\n      if (requireSuccess) {\n        require(success, \"multicall aggregate: call failed\");\n      }\n\n      returnData[i] = Result(success, ret);\n    }\n  }\n}\n\ncontract MultiCall is Block, Pair, ERC20, ERC721, Address, ChainLink, Aggregator {}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}