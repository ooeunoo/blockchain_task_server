{
  "language": "Solidity",
  "sources": {
    "contracts/MultiCall.sol": {
      "content": "pragma solidity 0.8.7;\npragma experimental ABIEncoderV2;\n\nabstract contract Ownable {\n    address private _owner;\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    \n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _owner = newOwner;\n    }\n}\n\nabstract contract Constant is Ownable {\n  string internal UNKNOWN_STRING = 'UNKNOWN';\n  uint256 internal UNKNOWN_UINT256 = 0;\n\n  function setUnKnownString(string memory _unknown) external onlyOwner {\n    UNKNOWN_STRING = _unknown;\n  }\n\n  function setUnknownUint256(uint256 _unknown) external onlyOwner {\n    UNKNOWN_UINT256 = _unknown;\n  }\n\n}\n\nabstract contract Block {\n  function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n    blockHash = blockhash(blockNumber);\n  }\n    \n  function getBlockNumber() public view returns (uint256 blockNumber) {\n    blockNumber = block.number;\n  }\n    \n  function getCurrentBlockCoinbase() public view returns (address coinbase) {\n\t  coinbase = block.coinbase;\n  }\n    \n  function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n\t  difficulty = block.difficulty;\n  }\n    \n  function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n    gaslimit = block.gaslimit;\n  }\n    \n  function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n    timestamp = block.timestamp;\n  }\n    \n  function getLastBlockHash() public view returns (bytes32 blockHash) {\n    blockHash = blockhash(block.number - 1);\n  }\n  \n  function getBlockBaseFee() public view returns (uint256 baseFee) {\n    baseFee = block.basefee;\n  }\n  \n  function getChainId() public view returns (uint256 chainId) {\n    chainId = block.chainid;\n  }\n}\n\nabstract contract Pair is Constant {\n  struct EachPair {\n    address token;\n    uint256 reserve;\n  }\n    \n  struct PairReserves {\n    address pair;\n    EachPair token0;\n    EachPair token1;\n  }\n    \n  function safePairReserve(address pair) internal view returns (EachPair memory token0, EachPair memory token1) {\n\t\t(bool successToken0, bytes memory token0Bytes) = pair.staticcall(abi.encodeWithSelector(0x0dfe1681));\n\t\trequire(successToken0, 'getPairReserve: Invalid Token0');\n\t\taddress token0Address = abi.decode(token0Bytes, (address));\n\n    (bool successToken1, bytes memory token1Bytes) = pair.staticcall(abi.encodeWithSelector(0xd21220a7));\n    require(successToken1, 'getPairReserve: Invalid Token1');\n    address token1Address = abi.decode(token1Bytes, (address));\n  \n\t  (bool successReserves, bytes memory reserve) = pair.staticcall(abi.encodeWithSelector(0x0902f1ac));\n    require(successReserves, 'getPairReserve: Invalid reserves');\n    (uint256 token0Reserve, uint256 token1Reserve) = abi.decode(reserve, (uint256, uint256));\n      \n    return (\n      EachPair({ token: token0Address, reserve: token0Reserve }), \n      EachPair({ token: token1Address, reserve: token1Reserve })\n    );\n  }\n    \n  function getBatchPairReserves(address[] memory _pairs) public view returns (PairReserves[] memory _pairReserves) {\n    _pairReserves = new PairReserves[](_pairs.length);\n    for (uint256 i = 0; i <_pairs.length; i++) {\n      address targetPair = _pairs[i];\n    \n      _pairReserves[i].pair = targetPair;\n      (_pairReserves[i].token0, _pairReserves[i].token1) = safePairReserve(targetPair);\n    }\n  }\n}\n\nabstract contract Token is Constant {\n    \n  struct TokenInfo {\n    string name;\n    string symbol;\n    uint256 decimals;\n    uint256 totalSupply;\n  }\n\n  function safeTokenName(address token) internal view returns (string memory) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x06fdde03));\n    return success ? string(data) : UNKNOWN_STRING; // abi.decode(data, (string)\n  }\n\n  function safeTokenSymbol(address token) internal view returns (string memory) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x95d89b41));\n    return success ? string(data) : UNKNOWN_STRING;  // abi.decode(data, (string)\n  }\n\n  function safeTokenDecimals(address token) internal view returns (uint256) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x313ce567));\n    return success ? abi.decode(data, (uint256)) : UNKNOWN_UINT256;\n  }\n    \n  function safeTokenTotalSupply(address token) internal view returns (uint256) {\n\t\t(bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\n\t\treturn success ? abi.decode(data, (uint256)) : UNKNOWN_UINT256;\n  }\n  \n  function safeTokenBalanceOf(address token, address user) internal view returns (uint256) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x70a08231, user));\n    return success ? abi.decode(data, (uint256)) : UNKNOWN_UINT256;\n  }\n    \n  function getBatchTokenInfos(address[] memory _tokens) public view returns (TokenInfo[] memory _tokenInfos) {\n    _tokenInfos = new TokenInfo[](_tokens.length);\n    for (uint256 i = 0; i < _tokens.length; i++) {\n      address targetToken = _tokens[i];\n         \n      _tokenInfos[i].name =  safeTokenName(targetToken);\n      _tokenInfos[i].symbol =  safeTokenSymbol(targetToken);\n      _tokenInfos[i].decimals =  safeTokenDecimals(targetToken);\n      _tokenInfos[i].totalSupply =  safeTokenTotalSupply(targetToken);\n    }\n  }\n    \n  function getBatchTokenBalances(address[] memory _tokens, address _user) public view returns (uint256[] memory balances) {\n        \n    for (uint256 i = 0; i < _tokens.length; i++) {\n      address targetToken = _tokens[i];\n    \n      balances[i] = targetToken == address(0) \n                    ? address(_user).balance\n                    : safeTokenBalanceOf(targetToken, _user);\n    }\n  }\n}\n\n// contract ChainLink is Constant {\n\n//   struct ChainLinkData {\n//     string description;\n//     uint256 answer;\n//     uint256 decimals;\n//   }\n\n//   function safeChainLinkData(address feed) public view returns (ChainLinkData memory) {\n//     (bool successDescriptionData, bytes memory desciprtionData) = feed.staticcall(abi.encodeWithSelector(0x7284e416));\n//     (bool successRoundData, bytes memory roundData) = feed.staticcall(abi.encodeWithSelector(0xfeaf968c));\n//     (bool successDecimalsData, bytes memory decimalsData) = feed.staticcall(abi.encodeWithSelector(0x313ce567));\n  \n// \t  string memory description = successDescriptionData ? string(desciprtionData) : UnKownString;\n//     (, uint256 answer, , , ) = successRoundData ? abi.decode(roundData, (uint80, uint256, uint256, uint256, uint80)) : (0, UnkownUint256, 0, 0, 0);\n//     uint256 decimals = successDecimalsData ? abi.decode(decimalsData, (uint256)) : 0;\n      \n//     return ChainLinkData({ description: description, answer: answer, decimals: decimals });\n//   }\n  \n    \n//   function getBatchChainLinkData(address[] memory _targetFeeds) public view returns (ChainLinkData[] memory _chainLinkData) {\n//     _chainLinkData = new ChainLinkData[](_targetFeeds.length);\n//     for (uint256 i = 0; i < _targetFeeds.length; i++) {\n//         address targetFeed = _targetFeeds[i];\n//         _chainLinkData[i] = safeChainLinkData(targetFeed);\n//     }\n//   }\n// }\n\nabstract contract Aggregator {\n    struct Call {\n      address target;\n      bytes callData;\n    }\n\n    struct Result {\n      bool success;\n      bytes returnData;\n    }\n\n    function aggregate(Call[] memory calls) public returns (uint256 blockNumber, bytes[] memory returnData) {\n      blockNumber = block.number;\n      returnData = new bytes[](calls.length);\n      for(uint256 i = 0; i < calls.length; i++) {\n        (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\n        require(success, \"Multicall aggregate: call failed\");\n        returnData[i] = ret;\n      }\n    }\n\n    function tryAggregate(bool requireSuccess, Call[] memory calls) public returns (Result[] memory returnData) {\n      returnData = new Result[](calls.length);\n      for(uint256 i = 0; i < calls.length; i++) {\n        (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\n\n        if (requireSuccess) {\n            require(success, \"Multicall2 aggregate: call failed\");\n        }\n\n        returnData[i] = Result(success, ret);\n      }\n    }\n\n    function tryBlockAndAggregate(bool requireSuccess, Call[] memory calls) public returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {\n      blockNumber = block.number;\n      blockHash = blockhash(block.number);\n      returnData = tryAggregate(requireSuccess, calls);\n    }\n}\n\ncontract MultiCall is Block, Token, Pair, Aggregator {}\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}