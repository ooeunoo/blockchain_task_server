{
  "language": "Solidity",
  "sources": {
    "contracts/MultiCall.sol": {
      "content": "pragma solidity 0.8.7;\npragma experimental ABIEncoderV2;\n\nlibrary Helper {\n  function isEmptyBytes(bytes memory _bytes) internal pure returns (bool) {\n    return _bytes.length == 0;\n  }\n}\n\nabstract contract Ownable {\n  address private _owner;\n\n  constructor() {\n    _owner = msg.sender;\n  }\n\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    _owner = newOwner;\n  }\n}\n\nabstract contract Constant is Ownable {\n  string public UNKNOWN_STRING = \"UNKNOWN\";\n  uint256 public UNKNOWN_UINT = 0;\n  address public UNKNOWN_ADDRESS = address(0);\n}\n\nabstract contract Block {\n  function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n    blockHash = blockhash(blockNumber);\n  }\n\n  function getBlockNumber() public view returns (uint256 blockNumber) {\n    blockNumber = block.number;\n  }\n\n  function getCurrentBlockCoinbase() public view returns (address coinbase) {\n    coinbase = block.coinbase;\n  }\n\n  function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n    difficulty = block.difficulty;\n  }\n\n  function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n    gaslimit = block.gaslimit;\n  }\n\n  function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n    timestamp = block.timestamp;\n  }\n\n  function getLastBlockHash() public view returns (bytes32 blockHash) {\n    blockHash = blockhash(block.number - 1);\n  }\n\n  function getBlockBaseFee() public view returns (uint256 baseFee) {\n    require(getChainId() == 1, \"Unable to get baseFee\");\n    baseFee = block.basefee;\n  }\n\n  function getChainId() public view returns (uint256 chainId) {\n    chainId = block.chainid;\n  }\n}\n\nabstract contract Pair is Constant {\n  struct PairInfo {\n    address pair;\n    address token0;\n    address token1;\n  }\n\n  function isPair(address pair) public view returns (bool) {\n    (, bytes memory token0Data) = pair.staticcall(abi.encodeWithSelector(0x0dfe1681));\n    (, bytes memory token1Data) = pair.staticcall(abi.encodeWithSelector(0xd21220a7));\n\n    return !Helper.isEmptyBytes(token0Data) && !Helper.isEmptyBytes(token1Data);\n  }\n\n  function safePairInfo(address pair) public view returns (PairInfo memory) {\n    (, bytes memory token0Data) = pair.staticcall(abi.encodeWithSelector(0x0dfe1681));\n    (, bytes memory token1Data) = pair.staticcall(abi.encodeWithSelector(0xd21220a7));\n\n    address token0Address = !Helper.isEmptyBytes(token0Data) ? abi.decode(token0Data, (address)) : UNKNOWN_ADDRESS;\n    address token1Address = !Helper.isEmptyBytes(token0Data) ? abi.decode(token1Data, (address)) : UNKNOWN_ADDRESS;\n\n    return PairInfo(pair, token0Address, token1Address);\n  }\n\n  function getBatchIsPairs(address[] memory _pairs) external view returns (bool[] memory _isPairs) {\n    _isPairs = new bool[](_pairs.length);\n    for (uint256 i = 0; i < _pairs.length; i++) {\n      _isPairs[i] = isPair(_pairs[i]);\n    }\n  }\n\n  function getBatchPairInfos(address[] memory _pairs) public view returns (PairInfo[] memory _pairInfos) {\n    _pairInfos = new PairInfo[](_pairs.length);\n    for (uint256 i = 0; i < _pairs.length; i++) {\n      _pairInfos[i] = safePairInfo(_pairs[i]);\n    }\n  }\n}\n\nabstract contract ERC20 is Constant {\n  struct ERC20Info {\n    string name;\n    string symbol;\n    uint256 decimals;\n  }\n\n  struct BalanceInfo {\n    address token;\n    uint256 balance;\n  }\n\n  function safeERC20Name(address token) public view returns (string memory) {\n    (, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x06fdde03));\n    return !Helper.isEmptyBytes(data) ? abi.decode(data, (string)) : UNKNOWN_STRING;\n  }\n\n  function safeERC20Symbol(address token) public view returns (string memory) {\n    (, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x95d89b41));\n    return !Helper.isEmptyBytes(data) ? abi.decode(data, (string)) : UNKNOWN_STRING;\n  }\n\n  function safeERC20Decimals(address token) public view returns (uint256) {\n    (, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x313ce567));\n    return !Helper.isEmptyBytes(data) ? abi.decode(data, (uint256)) : UNKNOWN_UINT;\n  }\n\n  function safeERC20TotalSupply(address token) public view returns (uint256) {\n    (, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\n    return !Helper.isEmptyBytes(data) ? abi.decode(data, (uint256)) : UNKNOWN_UINT;\n  }\n\n  function safeERC20BalanceOf(address token, address holder) public view returns (uint256) {\n    (, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x70a08231, holder));\n    return !Helper.isEmptyBytes(data) ? abi.decode(data, (uint256)) : UNKNOWN_UINT;\n  }\n\n  function getBatchERC20TotalSupply(address[] memory _tokens) public view returns (uint256[] memory totalSupplies) {\n    totalSupplies = new uint256[](_tokens.length);\n\n    for (uint256 i = 0; i < _tokens.length; i++) {\n      totalSupplies[i] = safeERC20TotalSupply(_tokens[i]);\n    }\n  }\n\n  function getBatchERC20Infos(address[] memory _tokens) public view returns (ERC20Info[] memory tokenInfos) {\n    tokenInfos = new ERC20Info[](_tokens.length);\n\n    for (uint256 i = 0; i < _tokens.length; i++) {\n      address targetERC20 = _tokens[i];\n      tokenInfos[i] = ERC20Info({name: safeERC20Name(targetERC20), symbol: safeERC20Symbol(targetERC20), decimals: safeERC20Decimals(targetERC20)});\n    }\n  }\n\n  function getBatchERC20Balances(address[] memory users, address[] memory tokens) external view returns (uint256[] memory addrBalances) {\n    addrBalances = new uint256[](tokens.length * users.length);\n\n    for (uint256 i = 0; i < users.length; i++) {\n      for (uint256 j = 0; j < tokens.length; j++) {\n        uint256 addrIdx = j + tokens.length * i;\n        if (tokens[j] != address(0x0)) {\n          addrBalances[addrIdx] = safeERC20BalanceOf(tokens[j], users[i]);\n        } else {\n          addrBalances[addrIdx] = users[i].balance;\n        }\n      }\n    }\n  }\n}\n\nabstract contract ERC721 is Constant {\n  struct ERC721Info {\n    uint256 id;\n    address owner;\n    string tokenURI;\n  }\n\n  function safeERC721OwnerOf(address token, uint256 id) public view returns (address) {\n    (, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\n    return !Helper.isEmptyBytes(data) ? abi.decode(data, (address)) : UNKNOWN_ADDRESS;\n  }\n\n  function safeERC721TokenURI(address token, uint256 id) public view returns (string memory) {\n    (, bytes memory data) = token.staticcall(abi.encodeWithSelector(0xc87b56dd, id));\n    return !Helper.isEmptyBytes(data) ? abi.decode(data, (string)) : UNKNOWN_STRING;\n  }\n\n  function safeERC721TokenByIndex(address token, uint256 index) public view returns (uint256) {\n    (, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x4f6ccce7, index));\n    require(!Helper.isEmptyBytes(data), \"invalid index\");\n    return abi.decode(data, (uint256));\n  }\n\n  function getBatchERC721Infos(address _token, uint256[] memory _indexes) public view returns (ERC721Info[] memory erc721Infos) {\n    erc721Infos = new ERC721Info[](_indexes.length);\n\n    for (uint256 i = 0; i < _indexes.length; i++) {\n      uint256 id = safeERC721TokenByIndex(_token, _indexes[i]);\n      erc721Infos[i] = ERC721Info({id: id, owner: safeERC721OwnerOf(_token, id), tokenURI: safeERC721TokenURI(_token, id)});\n    }\n  }\n}\n\nabstract contract ChainLink is Constant {\n  struct ChainLinkData {\n    uint256 answer;\n    uint256 decimals;\n  }\n\n  function safeChainLinkData(address feed) public view returns (ChainLinkData memory) {\n    (, bytes memory roundData) = feed.staticcall(abi.encodeWithSelector(0xfeaf968c));\n    (, bytes memory decimalsData) = feed.staticcall(abi.encodeWithSelector(0x313ce567));\n\n    (, uint256 answer, , , ) = !Helper.isEmptyBytes(roundData)\n      ? abi.decode(roundData, (uint80, uint256, uint256, uint256, uint80))\n      : (0, UNKNOWN_UINT, 0, 0, 0);\n    uint256 decimals = !Helper.isEmptyBytes(decimalsData) ? abi.decode(decimalsData, (uint256)) : 0;\n\n    return ChainLinkData({answer: answer, decimals: decimals});\n  }\n\n  function getBatchChainLinkData(address[] memory _targetFeeds) public view returns (ChainLinkData[] memory _chainLinkData) {\n    _chainLinkData = new ChainLinkData[](_targetFeeds.length);\n    for (uint256 i = 0; i < _targetFeeds.length; i++) {\n      address targetFeed = _targetFeeds[i];\n      _chainLinkData[i] = safeChainLinkData(targetFeed);\n    }\n  }\n}\n\nabstract contract Address {\n  function getCode(address target) public view returns (bytes memory code) {\n    assembly {\n      let size := extcodesize(target)\n      code := mload(0x40)\n      mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n      mstore(code, size)\n      extcodecopy(target, add(code, 0x20), 0, size)\n    }\n  }\n\n  function checkCA(address target) public view returns (bool) {\n    uint256 code;\n    assembly {\n      code := extcodesize(target)\n    }\n    return code > 0;\n  }\n\n  function getBatchGetCode(address[] memory _targetAddress) public view returns (bytes[] memory code) {\n    code = new bytes[](_targetAddress.length);\n    for (uint256 i = 0; i < _targetAddress.length; i++) {\n      code[i] = getCode(_targetAddress[i]);\n    }\n  }\n\n  function getBatchCheckCA(address[] memory _targetAddress) public view returns (bool[] memory result) {\n    result = new bool[](_targetAddress.length);\n    for (uint256 i = 0; i < _targetAddress.length; i++) {\n      result[i] = checkCA(_targetAddress[i]);\n    }\n  }\n}\n\nabstract contract Aggregator {\n  struct Call {\n    address target;\n    bytes callData;\n  }\n\n  struct Result {\n    bool success;\n    bytes returnData;\n  }\n\n  function aggregate(bool requireSuccess, Call[] memory calls) public returns (Result[] memory returnData) {\n    returnData = new Result[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n      (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\n\n      if (requireSuccess) {\n        require(success, \"multicall aggregate: call failed\");\n      }\n\n      returnData[i] = Result(success, ret);\n    }\n  }\n\n  function staticAggregate(bool requireSuccess, Call[] memory calls) public view returns (Result[] memory returnData) {\n    returnData = new Result[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n      (bool success, bytes memory ret) = calls[i].target.staticcall(calls[i].callData);\n\n      if (requireSuccess) {\n        require(success, \"multicall aggregate: call failed\");\n      }\n\n      returnData[i] = Result(success, ret);\n    }\n  }\n}\n\ncontract MultiCall is Block, Pair, ERC20, ERC721, Address, ChainLink, Aggregator {}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}