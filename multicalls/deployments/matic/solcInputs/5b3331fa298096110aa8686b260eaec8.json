{
  "language": "Solidity",
  "sources": {
    "contracts/MultiCall.sol": {
      "content": "pragma solidity 0.8.7;\npragma experimental ABIEncoderV2;\n\ninterface IERC20 {\n  function decimals() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n}\n\nabstract contract Ownable {\n  address private _owner;\n\n  constructor() {\n    _owner = msg.sender;\n  }\n\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    _owner = newOwner;\n  }\n}\n\nabstract contract Constant is Ownable {\n  string internal UNKNOWN_STRING = \"UNKNOWN\";\n  uint256 internal UNKNOWN_UINT256 = 0;\n\n  function setUnKnownString(string memory _unknown) external onlyOwner {\n    UNKNOWN_STRING = _unknown;\n  }\n\n  function setUnknownUint256(uint256 _unknown) external onlyOwner {\n    UNKNOWN_UINT256 = _unknown;\n  }\n}\n\nabstract contract Block {\n  function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n    blockHash = blockhash(blockNumber);\n  }\n\n  function getBlockNumber() public view returns (uint256 blockNumber) {\n    blockNumber = block.number;\n  }\n\n  function getCurrentBlockCoinbase() public view returns (address coinbase) {\n    coinbase = block.coinbase;\n  }\n\n  function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n    difficulty = block.difficulty;\n  }\n\n  function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n    gaslimit = block.gaslimit;\n  }\n\n  function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n    timestamp = block.timestamp;\n  }\n\n  function getLastBlockHash() public view returns (bytes32 blockHash) {\n    blockHash = blockhash(block.number - 1);\n  }\n\n  function getBlockBaseFee() public view returns (uint256 baseFee) {\n    require(getChainId() == 1, \"Unable to get baseFee\");\n    baseFee = block.basefee;\n  }\n\n  function getChainId() public view returns (uint256 chainId) {\n    chainId = block.chainid;\n  }\n}\n\nabstract contract Pair is Constant {\n  struct EachPair {\n    address token;\n    uint256 reserve;\n  }\n\n  struct PairReserves {\n    address pair;\n    EachPair token0;\n    EachPair token1;\n  }\n\n  function safePairReserve(address pair) internal view returns (EachPair memory token0, EachPair memory token1) {\n    (bool successToken0, bytes memory token0Bytes) = pair.staticcall(abi.encodeWithSelector(0x0dfe1681));\n    require(successToken0, \"getPairReserve: Invalid Token0\");\n    address token0Address = abi.decode(token0Bytes, (address));\n\n    (bool successToken1, bytes memory token1Bytes) = pair.staticcall(abi.encodeWithSelector(0xd21220a7));\n    require(successToken1, \"getPairReserve: Invalid Token1\");\n    address token1Address = abi.decode(token1Bytes, (address));\n\n    (bool successReserves, bytes memory reserve) = pair.staticcall(abi.encodeWithSelector(0x0902f1ac));\n    require(successReserves, \"getPairReserve: Invalid reserves\");\n    (uint256 token0Reserve, uint256 token1Reserve) = abi.decode(reserve, (uint256, uint256));\n\n    return (EachPair({token: token0Address, reserve: token0Reserve}), EachPair({token: token1Address, reserve: token1Reserve}));\n  }\n\n  function getBatchPairReserves(address[] memory _pairs) public view returns (PairReserves[] memory _pairReserves) {\n    _pairReserves = new PairReserves[](_pairs.length);\n    for (uint256 i = 0; i < _pairs.length; i++) {\n      address targetPair = _pairs[i];\n\n      _pairReserves[i].pair = targetPair;\n      (_pairReserves[i].token0, _pairReserves[i].token1) = safePairReserve(targetPair);\n    }\n  }\n}\n\nabstract contract Token is Constant {\n  struct TokenInfo {\n    string name;\n    string symbol;\n    uint256 decimals;\n    uint256 totalSupply;\n  }\n\n  struct BalanceInfo {\n    address token;\n    uint256 balance;\n  }\n\n  function safeTokenName(address token) public view returns (string memory) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x06fdde03));\n    return success ? abi.decode(data, (string)) : UNKNOWN_STRING; // abi.decode(data, (string)\n  }\n\n  function safeTokenSymbol(address token) public view returns (string memory) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x95d89b41));\n    return success ? abi.decode(data, (string)) : UNKNOWN_STRING; // abi.decode(data, (string)\n  }\n\n  function safeTokenDecimals(address token) public view returns (uint256) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x313ce567));\n    return success ? abi.decode(data, (uint256)) : UNKNOWN_UINT256;\n  }\n\n  function safeTokenTotalSupply(address token) public view returns (uint256) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\n    return success ? abi.decode(data, (uint256)) : UNKNOWN_UINT256;\n  }\n\n  function safeTokenBalanceOf(address token, address holder) public view returns (uint256) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x70a08231, holder));\n    return success ? abi.decode(data, (uint256)) : UNKNOWN_UINT256;\n  }\n\n  function getBatchTokenInfos(address[] memory _tokens) public view returns (TokenInfo[] memory tokenInfos) {\n    tokenInfos = new TokenInfo[](_tokens.length);\n\n    for (uint256 i = 0; i < _tokens.length; i++) {\n      address targetToken = _tokens[i];\n      tokenInfos[i] = TokenInfo({\n        name: safeTokenName(targetToken), // optional\n        symbol: safeTokenSymbol(targetToken), // optional\n        decimals: IERC20(targetToken).decimals(), // required\n        totalSupply: IERC20(targetToken).totalSupply() // required\n      });\n    }\n  }\n\n  function getBatchTokenBalances(address[] memory users, address[] memory tokens) external view returns (uint256[] memory addrBalances) {\n    addrBalances = new uint256[](tokens.length * users.length);\n\n    for (uint256 i = 0; i < users.length; i++) {\n      for (uint256 j = 0; j < tokens.length; j++) {\n        uint256 addrIdx = j + tokens.length * i;\n        if (tokens[j] != address(0x0)) {\n          addrBalances[addrIdx] = IERC20(tokens[j]).balanceOf(users[i]);\n        } else {\n          addrBalances[addrIdx] = users[i].balance;\n        }\n      }\n    }\n  }\n}\n\nabstract contract ChainLink is Constant {\n  struct ChainLinkData {\n    uint256 answer;\n    uint256 decimals;\n  }\n\n  function safeChainLinkData(address feed) public view returns (ChainLinkData memory) {\n    (bool successRoundData, bytes memory roundData) = feed.staticcall(abi.encodeWithSelector(0xfeaf968c));\n    (bool successDecimalsData, bytes memory decimalsData) = feed.staticcall(abi.encodeWithSelector(0x313ce567));\n\n    (, uint256 answer, , , ) = successRoundData\n      ? abi.decode(roundData, (uint80, uint256, uint256, uint256, uint80))\n      : (0, UNKNOWN_UINT256, 0, 0, 0);\n    uint256 decimals = successDecimalsData ? abi.decode(decimalsData, (uint256)) : 0;\n\n    return ChainLinkData({ answer: answer, decimals: decimals});\n  }\n\n  function getBatchChainLinkData(address[] memory _targetFeeds) public view returns (ChainLinkData[] memory _chainLinkData) {\n    _chainLinkData = new ChainLinkData[](_targetFeeds.length);\n    for (uint256 i = 0; i < _targetFeeds.length; i++) {\n      address targetFeed = _targetFeeds[i];\n      _chainLinkData[i] = safeChainLinkData(targetFeed);\n    }\n  }\n}\n\nabstract contract Aggregator {\n  struct Call {\n    address target;\n    bytes callData;\n  }\n\n  struct Result {\n    bool success;\n    bytes returnData;\n  }\n\n  function aggregate(bool requireSuccess, Call[] memory calls) public returns (Result[] memory returnData) {\n    returnData = new Result[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n      (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\n\n      if (requireSuccess) {\n        require(success, \"multicall aggregate: call failed\");\n      }\n\n      returnData[i] = Result(success, ret);\n    }\n  }\n\n  function staticAggregate(bool requireSuccess, Call[] memory calls) public view returns (Result[] memory returnData) {\n    returnData = new Result[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n      (bool success, bytes memory ret) = calls[i].target.staticcall(calls[i].callData);\n\n      if (requireSuccess) {\n        require(success, \"multicall aggregate: call failed\");\n      }\n\n      returnData[i] = Result(success, ret);\n    }\n  }\n}\n\ncontract MultiCall is Block, Pair, Token, ChainLink, Aggregator {}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}